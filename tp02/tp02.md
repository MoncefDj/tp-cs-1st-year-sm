<div dir="rtl" align="right">

### **التمرين 1: حساب مساحة مستطيل**

**الهدف:** إتقان قراءة المُدخلات من المستخدم، تحويل أنواع البيانات، إجراء عمليات حسابية بسيطة، وطباعة النتائج بشكل منسق.

**المطلوب:**
اكتب برنامجاً بلغة بايثون يقوم بالتالي:

1.  يطلب من المستخدم إدخال **عرض** المستطيل.
2.  يطلب من المستخدم إدخال **طول** نفس المستطيل.
3.  يحسب **مساحة** المستطيل (المساحة = الطول × العرض).
4.  يعرض النتيجة النهائية بصيغة واضحة، على سبيل المثال: "مساحة مستطيل عرضه 5.5 وطوله 10.0 هي 55.0".

خذ بضع لحظات لكتابة الكود. لا تقلق إن لم يكن مثالياً، فالمهم هو المحاولة!

---

#### **الحل والشرح**

إليك حل ممكن بلغة بايثون، مع استخدام أسماء متغيرات باللغة العربية لزيادة الوضوح:

![alt text](image-1.png)

#### **شرح مفصّل**

1.  **`al_ard = float(input("..."))`**

    - **`input("...")`**: هذه هي الدالة التي تتفاعل مع المستخدم. تعرض الرسالة بين القوسين ("الرجاء إدخال...") في الشاشة وتنتظر من المستخدم أن يكتب شيئاً ويضغط على "Enter".
    - **نقطة مهمة:** الدالة `input()` تُرجع **دائماً** نصاً (_string_)، حتى لو كتب المستخدم أرقاماً! لا يمكننا إجراء عمليات حسابية على النصوص.
    - **`float(...)`**: هذه هي الدالة التي تحول النص إلى رقم عشري (_floating-point number_). على سبيل المثال، النص `"10.5"` يصبح الرقم `10.5`. نستخدم `float` بدلاً من `int` (للأرقام الصحيحة) تحسباً لوجود أبعاد تحتوي على فواصل عشرية.
    - **`al_ard = ...`**: هذه عملية ال**إسناد** (_assignment_). نحن ننشئ "صندوقاً" في الذاكرة، نعطيه الاسم `al_ard`، ونخزن فيه القيمة التي أدخلها المستخدم بعد تحويلها.

2.  **`al_misaha = al_ard * al_tool`**

    - هنا، نُعرّف متغيراً جديداً اسمه `al_misaha`.
    - العامل `*` يقوم بعملية ضرب القيمتين المخزنتين في المتغيرين `al_ard` و `al_tool`.
    - يتم تخزين (إسناد) نتيجة هذه العملية الحسابية في المتغير `al_misaha`.

3.  **`print(f"...")`**
    - **`print()`** هي الدالة المسؤولة عن عرض المعلومات على الشاشة.
    - الحرف **`f`** قبل علامات التنصيص مباشرةً يُفعّل أداة قوية جداً تسمى **f-string**. تسمح هذه الأداة بدمج المتغيرات مباشرة داخل النص عن طريق وضعها بين قوسي مجموعة `{}`.
    - يقوم بايثون تلقائياً باستبدال `{al_ard}` و `{al_tool}` و `{al_misaha}` بالقيم المخزنة فيها عند الطباعة. هذه الطريقة أكثر نظافة وسهولة في القراءة من محاولة "لصق" أجزاء من النصوص والمتغيرات معاً.

---

#### **✅ نقاط رئيسية ونصيحة للامتحان**

- **النقاط الأساسية التي يجب تذكرها:**

  - `input()` لطلب المُدخلات، `print()` لعرض المخرجات.
  - **دائماً** حوّل البيانات القادمة من `input()` باستخدام `int()` أو `float()` قبل إجراء أي عملية حسابية. هذا خطأ شائع جداً يقع فيه المبتدئون.
  - استخدم أسماء متغيرات واضحة وذات معنى (مثل `al_ard`, `al_misaha`) لجعل الكود الخاص بك سهل الفهم.

- **نصيحة للامتحان:**
  - إذا طُلب منك كتابة برنامج في الامتحان، أضف تعليقات (باستخدام الرمز `#`) كما فعلتُ في الحل. هذا يُظهر للمصحح أنك تفهم كل خطوة من منطقك، حتى لو ارتكبت خطأً بسيطاً في الصيغة.

---

### **التمرين 2: التحقق من الأهلية العمرية**

**الهدف:** استخدام `if` و `else` لاتخاذ قرار بناءً على شرط، مع تعزيز مهارات الإدخال والتحويل واستخدام عوامل المقارنة.

**المطلوب:**
اكتب برنامجاً بلغة بايثون يقوم بالتالي:

1.  يطلب من المستخدم إدخال عمره.
2.  يتحقق مما إذا كان العمر 18 عاماً أو أكثر.
3.  إذا كان الشرط صحيحاً (العمر >= 18)، يطبع رسالة: "**أنت راشد.**"
4.  وإلا (إذا كان الشرط خاطئاً)، يطبع رسالة: "**أنت قاصر.**"

خذ وقتك في التفكير وكتابة الحل.

---

#### **الحل والشرح**

إليك الحل النموذجي في بايثون:

![alt text](image-2.png)

#### **شرح مفصّل**

1.  **`al_omr = int(input(...))`**

    - كما في التمرين السابق، نستخدم `input()` لأخذ المعلومة من المستخدم.
    - لكن هذه المرة، استخدمنا **`int()`** بدلاً من `float()`. لماذا؟ لأن العمر يُعبّر عنه عادةً بعدد صحيح (e.g., 17, 18, 25) وليس عدداً عشرياً (e.g., 17.5). اختيار النوع الصحيح للبيانات ممارسة جيدة في البرمجة.

2.  **`if al_omr >= 18:`**

    - **`if`**: هذه الكلمة المفتاحية تعني "إذا كان". إنها بداية البنية الشرطية.
    - **`al_omr >= 18`**: هذا هو **الشرط** (_condition_). إنه عبارة عن مقارنة سيُقيّمها بايثون ويحدد ما إذا كانت نتيجتها `True` (صحيح) أم `False` (خاطئ).
    - **`>=`**: هذا هو **عامل المقارنة** (_comparison operator_) ويعني "أكبر من أو يساوي". (هناك عوامل أخرى مثل `==` للمساواة، `!=` لعدم المساواة، `<` أصغر من، `>` أكبر من).
    - **`:`**: النقطتان الرأسيتان في نهاية السطر إلزاميتان. وهما تعنيان "إذن قم بتنفيذ ما يلي:".

3.  **المسافة البادئة (Indentation)**

    - لاحظ أن السطر `print("أنت راشد.")` مزاح قليلاً إلى اليمين. هذه **المسافة البادئة** (عادة 4 مسافات أو ضغطة Tab) **مهمة جداً** في بايثون. إنها الطريقة التي يفهم بها بايثون أن هذا السطر يتبع للـ `if`. أي أن هذا السطر لن يتم تنفيذه إلا إذا كان الشرط صحيحاً.

4.  **`else:`**
    - **`else`**: هذه الكلمة تعني "وإلا" أو "في الحالات الأخرى". يتم تنفيذ الكود الذي يتبعها فقط عندما يكون شرط الـ `if` الأصلي خاطئاً (`False`).
    - الـ `else` لا تأخذ شرطاً بنفسها، هي ببساطة تغطي جميع الحالات التي لم يغطيها الـ `if`.
    - لاحظ وجود النقطتين الرأسيتين **`:`** والمسافة البادئة للسطر الذي يتبعها، تماماً مثل `if`.

---

#### **✅ نقاط رئيسية ونصيحة للامتحان**

- **النقاط الأساسية التي يجب تذكرها:**

  - البنية الأساسية هي: `if condition: ... else: ...`
  - النقطتان الرأسيتان **`:`** والمسافات البادئة **إجبارية** وليست اختيارية. نسيانها يسبب خطأ في البرنامج (SyntaxError).
  - الشرط يجب أن يكون شيئاً يمكن تقييمه كـ `True` أو `False`.

- **نصيحة للامتحان:**
  - في الامتحانات، غالباً ما يتم اختبار فهمك للمسافات البادئة. تأكد من أن الكود الذي تكتبه منظم بشكل صحيح.
  - فكر دائماً في "الحالات الحدية" (edge cases). في مثالنا، ماذا يحدث لو أدخل المستخدم 18 بالضبط؟ بفضل استخدام `=>`، سيعتبره البرنامج "راشد"، وهو السلوك الصحيح.

---

### **التمرين 3: نظام تقدير الدرجات**

**الهدف:** استخدام سلسلة `if/elif/else` كاملة للتعامل مع حالات متعددة، والتدرب على الشروط التي تتضمن نطاقات من الأرقام.

**المطلوب:**
اكتب برنامجاً بلغة بايثون يقوم بالتالي:

1.  يطلب من المستخدم إدخال درجة طالب (رقم من 0 إلى 100).
2.  بناءً على الدرجة، يطبع التقدير المناسب وفقاً للقواعد التالية:
    - إذا كانت الدرجة 90 أو أعلى، يطبع "**التقدير: ممتاز**".
    - إذا كانت الدرجة بين 80 و 89، يطبع "**التقدير: جيد جداً**".
    - إذا كانت الدرجة بين 70 و 79، يطبع "**التقدير: جيد**".
    - إذا كانت الدرجة بين 60 و 69، يطبع "**التقدير: مقبول**".
    - إذا كانت الدرجة أقل من 60، يطبع "**التقدير: راسب**".

فكر جيداً في ترتيب الشروط. هذا مهم جداً في هذا التمرين.

---

#### **الحل والشرح**

إليك طريقة فعالة لحل هذه المسألة:

![alt text](image-3.png)

#### **شرح مفصّل**

1.  **`elif al_daraga >= 80:`**

    - **`elif`**: هذه هي الإضافة الجديدة. بايثون يقوم بالتحقق من هذا الشرط **فقط إذا كان شرط `if` الذي يسبقه خاطئاً (`False`)**.
    - **المنطق التسلسلي (وهو سر الحل!):**
      - لنفترض أن الطالب حصل على درجة `85`.
      - يسأل بايثون: هل `85 >= 90`؟ الجواب `False`.
      - لأن شرط `if` الأول كان خاطئاً، ينتقل بايثون إلى الـ `elif`.
      - يسأل بايثون: هل `85 >= 80`؟ الجواب `True`.
      - بما أن الشرط صحيح، يقوم بايثون بطباعة "التقدير: جيد جداً"، ثم **يتجاهل تماماً** بقية الشروط (`elif` و `else`) في هذه السلسلة ويخرج منها.
    - هذا الترتيب من الأكبر إلى الأصغر يضمن لنا أننا لا نحتاج لكتابة شرط معقد مثل `if al_daraga >= 80 and al_daraga < 90`. لأننا لو وصلنا إلى هذا السطر، فنحن نعرف **بالتأكيد** أن الدرجة ليست أكبر من 90.

2.  **`else:` في النهاية**
    - الـ `else` هنا تعمل كـ"شبكة أمان" أو "الحالة الافتراضية". إذا وصل البرنامج إليها، فهذا يعني أن **كل** الشروط التي سبقتها (`if` وجميع `elif`) كانت خاطئة.
    - في سياق هذا التمرين، إذا كانت الدرجة ليست `=>90` وليست `=>80` وليست `=>70` وليست `=>60`، فمن المؤكد أنها أقل من 60.

---

#### **✅ نقاط رئيسية ونصيحة للامتحان**

- **النقاط الأساسية التي يجب تذكرها:**

  - استخدم `if/elif/else` عندما يكون لديك **أكثر من نتيجتين** محتملتين.
  - **الترتيب مهم للغاية!** ابدأ دائماً بالشرط الأكثر تحديداً (أو الأعلى/الأدنى قيمة) ثم تدرج. لو بدأت بـ `if al_daraga >= 60`، فإن درجة مثل 95 ستحقق هذا الشرط وسيتم طباعة "مقبول"، وهذا خطأ منطقي.
  - في سلسلة `if/elif/.../else`، سيتم تنفيذ **كتلة كود واحدة فقط** على الأكثر.

- **نصيحة للامتحان:**
  - إذا واجهت سؤالاً يتطلب تصنيف شيء ما بناءً على نطاقات (مثل درجات، أسعار، فئات عمرية)، فإن سلسلة `if/elif/else` هي الأداة المثالية.
  - قبل كتابة الكود، فكر في الترتيب المنطقي للشروط على ورقة مسودة لتجنب الأخطاء.

---

### **التمرين 4: العداد البسيط**

**الهدف:** فهم البنية الأساسية لحلقة `while`: نقطة البداية (التهيئة)، الشرط، جسم الحلقة، وخطوة التحديث لتجنب حلقة لا نهائية.

**المطلوب:**
اكتب برنامجاً بلغة بايثون يقوم بعدّ الأرقام من 1 إلى 5، ويطبع كل رقم في سطر منفصل.

**المخرجات المتوقعة:**

```
1
2
3
4
5
```

هذا التمرين هو "أهلاً بالعالم" الخاص بالحلقات التكرارية. خذ وقتك لكتابة الكود.

---

#### **الحل والشرح**

![alt text](image-4.png)

#### **شرح مفصّل**

لنقسم حلقة `while` إلى أجزائها الأربعة الأساسية:

1.  **التهيئة (Initialization): `adad = 1`**
    قبل أن تبدأ الحلقة، تحتاج إلى متغير ليعمل كـ"عداد". نحن نضبط قيمته الأولية على 1 لأننا نريد أن نبدأ العد من هذا الرقم.

2.  **الشرط (Condition): `while adad <= 5:`**

    - **`while`**: كلمة مفتاحية تعني "طالما أن".
    - **`adad <= 5`**: هذا هو الشرط الذي يتم التحقق منه **قبل كل دورة جديدة**. إذا كانت نتيجته `True`، يتم تنفيذ الكود داخل الحلقة. إذا كانت `False`، يتم الخروج من الحلقة ومتابعة تنفيذ الكود الذي يأتي بعدها.

3.  **جسم الحلقة (Loop Body):**
    هو الكود الموجود داخل الحلقة (المعرف بالمسافة البادئة). في مثالنا، هو فقط `print(adad)`. هذا الكود هو الذي يتكرر.

4.  **خطوة التحديث (Update): `adad = adad + 1`**
    هذه هي الخطوة التي تغير قيمة المتغير المستخدم في الشرط، لتقترب خطوة من نهايتها. بدون هذه الخطوة، ستقع في **"حلقة لا نهائية" (Infinite Loop)**، لأن الشرط `1 <= 5` سيظل صحيحاً إلى الأبد، وسيستمر البرنامج في طباعة الرقم 1 دون توقف.

**كيف يفكر بايثون أثناء تنفيذ هذا الكود؟**

- **الدورة 1:** `adad` هو 1. هل 1 <= 5؟ **نعم**. إذن، اطبع `1`. ثم زد `adad` ليصبح `2`.
- **الدورة 2:** `adad` هو 2. هل 2 <= 5؟ **نعم**. إذن، اطبع `2`. ثم زد `adad` ليصبح `3`.
- **الدورة 3:** `adad` هو 3. هل 3 <= 5؟ **نعم**. إذن، اطبع `3`. ثم زد `adad` ليصبح `4`.
- **الدورة 4:** `adad` هو 4. هل 4 <= 5؟ **نعم**. إذن، اطبع `4`. ثم زد `adad` ليصبح `5`.
- **الدورة 5:** `adad` هو 5. هل 5 <= 5؟ **نعم**. إذن، اطبع `5`. ثم زد `adad` ليصبح `6`.
- **الدورة 6:** `adad` هو 6. هل 6 <= 5؟ **لا**. إذن، **اخرج من الحلقة** وانتقل إلى السطر التالي.
- ينفذ السطر `print("انتهى العد!")`.

---

#### **✅ نقاط رئيسية ونصيحة للامتحان**

- **النقاط الأساسية التي يجب تذكرها:**

  - تتكون حلقة `while` من 4 أجزاء: تهيئة، شرط، جسم، وتحديث.
  - احذر دائماً من **الحلقات اللا نهائية**. تأكد من أن هناك شيئاً ما داخل الحلقة يغير الشرط ليصبح `False` في النهاية.
  - `adad += 1` هي طريقة مختصرة وأكثر شيوعاً لكتابة `adad = adad + 1`.

- **نصيحة للامتحان:**
  - تُستخدم حلقة `while` بشكل مثالي عندما **لا تعرف بالضبط عدد المرات** التي تحتاج فيها إلى تكرار الكود، ولكنك تعرف شرط التوقف (مثال: استمر في طلب كلمة المرور حتى يدخل المستخدم الكلمة الصحيحة).

---

### **التمرين 5: العدّ باستخدام حلقة `for`**

**الهدف:** فهم بنية حلقة `for` وكيفية استخدام الدالة `range()` لتوليد سلسلة من الأرقام بشكل فعال.

**المطلوب:**
لنحل **نفس المشكلة السابقة**، ولكن هذه المرة باستخدام حلقة `for`. اكتب برنامجاً يقوم بعدّ الأرقام من 1 إلى 5، ويطبع كل رقم في سطر منفصل.

**المخرجات المتوقعة (نفسها):**

```
1
2
3
4
5
```

خذ لحظة للتفكير في كيف يمكن أن تكون هذه الطريقة أبسط.

---

#### **الحل والشرح**

![alt text](image-5.png)

#### **شرح مفصّل**

لاحظ كيف أن الحل أقصر وأكثر وضوحاً من حل حلقة `while` لنفس المسألة. هذا لأن حلقة `for` تتولى إدارة العداد تلقائياً. لنحلل السطر الرئيسي:

**`for adad in range(1, 6):`**

- **`for`**: كلمة مفتاحية تعني "لكل عنصر في...".
- **`adad`**: هذا **متغير مؤقت**. يمكنك تسميته أي شيء (`i`, `x`, `num`, etc.). في كل دورة من الحلقة، سيقوم بايثون بوضع العنصر التالي من المجموعة في هذا المتغير تلقائياً.
- **`in`**: كلمة مفتاحية تعني "في". هي الرابط بين المتغير المؤقت والمجموعة التي نمر عليها.
- **`range(1, 6)`**: هذه هي الدالة السحرية هنا.
  - `range()` هي دالة مدمجة في بايثون تقوم بإنشاء سلسلة من الأرقام.
  - عندما تأخذ رقمين، `range(start, stop)`، فإنها تنشئ أرقاماً تبدأ من `start` وتتوقف **قبل** الوصول إلى `stop`.
  - إذن، `range(1, 6)` تولد السلسلة التالية: `1, 2, 3, 4, 5`. **الرقم 6 غير مشمول!** وهذه نقطة مهمة جداً يجب تذكرها.

**ما الذي تفعله حلقة `for` تلقائياً؟**

مقارنة بحلقة `while`، فإن حلقة `for` قامت بالمهام التالية بدلاً منك:

1.  **التهيئة (Initialization):** لم تكن بحاجة لكتابة `adad = 1`. حلقة `for` بدأت بالرقم الأول من `range()` تلقائياً.
2.  **الشرط (Condition):** لم تكن بحاجة لكتابة `while adad <= 5`. حلقة `for` تعرف متى تنتهي السلسلة التي ولدتها `range()`، وتتوقف من تلقاء نفسها.
3.  **التحديث (Update):** لم تكن بحاجة لكتابة `adad = adad + 1`. حلقة `for` تنتقل إلى العنصر التالي في السلسلة في كل دورة تلقائياً.

---

#### **✅ نقاط رئيسية ونصيحة للامتحان**

- **النقاط الأساسية التي يجب تذكرها:**

  - تُستخدم `for` للتكرار على **تسلسل** أو مجموعة (مثل ناتج `range()`, أو الحروف في كلمة, أو العناصر في قائمة).
  - `for` تدير العداد تلقائياً.
  - تذكر دائماً أن `range(start, stop)` **لا تشمل** قيمة `stop`.

- **نصيحة للامتحان (سؤال كلاسيكي): متى تختار `for` ومتى تختار `while`؟**
  - **استخدم `for`:** عندما تعرف **عدد مرات التكرار** مسبقاً. (مثال: "لكل طالب من الطلاب العشرة"، "لكل شهر في السنة"، "من 1 إلى 50").
  - **استخدم `while`:** عندما **لا تعرف عدد مرات التكرار**، ولكنك تعرف **شرط التوقف**. (مثال: "استمر في طلب الإدخال حتى يكتب المستخدم 'خروج'"، "استمر في اللعبة طالما أن نقاط اللاعب فوق الصفر").

---

### **التمرين 6: طباعة حروف الكلمة**

**الهدف:** تطبيق حلقة `for` للمرور على كل عنصر في تسلسل غير رقمي (سلسلة نصية).

**المطلوب:**
اكتب برنامجاً يقوم بالتالي:

1.  يطلب من المستخدم إدخال كلمة واحدة.
2.  يستخدم حلقة `for` للمرور على **كل حرف** من حروف الكلمة.
3.  يطبع كل حرف على سطر منفصل.

**مثال على المخرجات:**
إذا أدخل المستخدم كلمة "**بايثون**"، يجب أن تكون المخرجات:

```
ب
ا
ي
ث
و
ن
```

فكر في مدى تشابه هذا مع التمرين السابق. ما هو الشيء الذي ستمر عليه الحلقة هذه المرة بدلاً من `range()`؟

---

#### **الحل والشرح**

![alt text](image-6.png)

#### **شرح مفصّل**

هذا هو نفس مبدأ حلقة `for` التي رأيناها مع `range()`, ولكن بطريقة أكثر مباشرة.

**`for harf in kalima:`**

- **`kalima`**: هذا هو المتغير الذي يحتوي على السلسلة النصية التي أدخلها المستخدم (مثلاً، "بايثون"). بايثون يعتبر هذه السلسلة **تسلسلاً (sequence)** يمكن المرور على عناصره.
- **`for harf in ...`**: أنت تقول لبايثون: "أنشئ لي متغيراً مؤقتاً اسمه `harf`. في الدورة الأولى، ضع فيه الحرف الأول من `kalima`. في الدورة الثانية، ضع فيه الحرف الثاني، وهكذا، حتى تصل إلى نهاية الكلمة".
- **لا حاجة لـ `range()`:** عندما تمر مباشرة على تسلسل مثل سلسلة نصية، لست بحاجة لـ `range()` لأن لديك بالفعل المجموعة التي تريد المرور عليها.

**كيف يفكر بايثون أثناء تنفيذ هذا الكود (إذا كانت الكلمة "أهلاً")؟**

1.  **الدورة 1:** `harf` يأخذ قيمة أول عنصر في "أهلاً"، وهي `'أ'`. الكود `print(harf)` يطبع `'أ'`.
2.  **الدورة 2:** `harf` يأخذ قيمة ثاني عنصر، وهي `'ه'`. الكود `print(harf)` يطبع `'ه'`.
3.  **الدورة 3:** `harf` يأخذ قيمة ثالث عنصر، وهي `'ل'`. الكود `print(harf)` يطبع `'ل'`.
4.  **الدورة 4:** `harf` يأخذ قيمة رابع عنصر، وهي `'اً'`. الكود `print(harf)` يطبع `'اً'`.
5.  وصل بايثون إلى نهاية السلسلة. تتوقف الحلقة تلقائياً.

---

#### **✅ نقاط رئيسية ونصيحة للامتحان**

- **النقاط الأساسية التي يجب تذكرها:**

  - حلقات `for` ليست مخصصة للأرقام فقط. إنها تعمل بشكل رائع مع أي شيء يمكن اعتباره تسلسلاً: السلاسل النصية، القوائم (Lists)، وغيرها.
  - بساطة الكود هي قوته. أنت لا تحتاج إلى عدادات أو مؤشرات معقدة للوصول إلى كل حرف.

- **نصيحة للامتحان:**
  - هذا المفهوم هو أساس حل العديد من المسائل الشائعة في الامتحانات، مثل:
    - عدّ عدد مرات ظهور حرف معين في جملة.
    - البحث عن حرف أو كلمة داخل نص.
    - إنشاء نسخة معكوسة من كلمة.
  - إتقان هذه الفكرة البسيطة يفتح لك الباب لحل مسائل أكثر تعقيداً.

---

### **التمرين 7: البحث عن أول حرف محدد**

**الهدف:** استخدام `break` لإيقاف حلقة تكرارية بشكل فوري عند تحقق شرط معين (العثور على ما نبحث عنه).

**المطلوب:**
اكتب برنامجاً يبحث عن أول ظهور لحرف 'س' في الجملة التالية: `"هذه سلسلة من الكلمات"`.

- عندما يجد البرنامج حرف 'س'، يجب أن يطبع رسالة: `"تم العثور على الحرف!"` ثم **يتوقف البحث فوراً**.
- للتوضيح، أضف طباعة للحرف الذي يتم التحقق منه في كل دورة.

فكر كيف ستستخدم `if` داخل حلقة `for` لتحديد متى يجب استدعاء `break`.

---

#### **الحل والشرح**

![alt text](image-7.png)

#### **شرح مفصّل**

**المخرجات المتوقعة من هذا الكود:**

```
بدأ البحث عن حرف 'س'...
أتحقق الآن من الحرف: 'ه'
أتحقق الآن من الحرف: 'ذ'
أتحقق الآن من الحرف: 'ه'
أتحقق الآن من الحرف: ' '
أتحقق الآن من الحرف: 'س'
تم العثور على الحرف!
...انتهى البحث.
```

1.  **`if harf == 'س':`**
    هذا شرط بسيط يتحقق مما إذا كان الحرف الذي وصلته الحلقة حالياً هو 'س'.

2.  **`break`**
    - هذه هي الكلمة المفتاحية الجديدة. `break` تعني **"اكسر الحلقة الآن!"** أو **"اخرج فوراً"**.
    - بمجرد أن ينفذ بايثون هذا الأمر، فإنه يخرج من حلقة `for` تماماً، بغض النظر عن عدد الحروف المتبقية في الجملة.
    - لاحظ في المخرجات كيف توقف البرنامج بعد العثور على أول حرف 'س' في كلمة "سلسلة". لم يكمل التحقق من بقية الحروف ("لسلة من الكلمات")، وهذا يجعل البرنامج أكثر كفاءة.

---

#### **✅ نقاط رئيسية ونصيحة للامتحان**

- **النقاط الأساسية التي يجب تذكرها:**

  - `break` تخرج من الحلقة **الأقرب** التي تحتويها.
  - تُستخدم دائماً داخل جملة شرطية (`if`)، لأنه نادراً ما تريد الخروج من الحلقة دون شرط.
  - الهدف الرئيسي من `break` هو تحسين **كفاءة** البرنامج عن طريق تجنب العمل غير الضروري.

- **نصيحة للامتحان:**
  - في الامتحانات، غالباً ما تأتي مسائل البحث (ابحث عن رقم، عن اسم، عن أول قيمة سلبية...). `break` هي أداتك الأساسية لحل هذه المسائل بكفاءة. إذا طلب منك "إيجاد العنصر الأول فقط"، فهذه إشارة قوية لاستخدام `break`.

---

### **التمرين 8: إزالة الحروف المتحركة**

**الهدف:** استخدام `continue` لتخطي دورات معينة في حلقة تكرارية بناءً على شرط، مع التدرب على بناء سلسلة نصية جديدة.

**المطلوب:**
اكتب برنامجاً يقوم بفلترة جملة معينة لإزالة كل الحروف المتحركة (Vowels). الحروف المتحركة التي سنعتبرها هي: 'ا', 'و', 'ي', 'أ', 'إ', 'آ'.

1.  ابدأ بالجملة التالية: `"مبرمج بايثون محترف"`.
2.  استخدم حلقة `for` للمرور على كل حرف.
3.  إذا كان الحرف أحد الحروف المتحركة، **تخطاه** وانتقل إلى الحرف التالي.
4.  إذا لم يكن الحرف متحركاً، أضفه إلى سلسلة نصية جديدة.
5.  في النهاية، اطبع السلسلة النصية الجديدة التي تحتوي فقط على الحروف الصامتة.

**المخرجات المتوقعة:**
`مبرمج بيثن محترف` (لاحظ كيف اختفت 'ا' و 'و' و 'و').

---

#### **الحل والشرح**

![alt text](image-8.png)

#### **شرح مفصّل**

1.  **`al_jumla_al_jadida = ""`**
    لقد أنشأنا متغيراً جديداً وهو عبارة عن سلسلة نصية فارغة. سنستخدمه لتجميع الحروف التي نريد الاحتفاظ بها تدريجياً.

2.  **`al_huruf_al_mutaharika = "اويأإآ"`**
    وضع كل الحروف التي نريد تجاهلها في سلسلة نصية واحدة يجعل الشرط التالي أسهل في القراءة والكتابة.

3.  **`if harf in al_huruf_al_mutaharika:`**
    هذا شرط قوي ومقروء. إنه يتحقق مما إذا كانت قيمة المتغير `harf` موجودة **كجزء** من السلسلة النصية `al_huruf_al_mutaharika`. هذا أفضل بكثير من كتابة: `if harf == 'ا' or harf == 'و' or ...`

4.  **`continue`**

    - عندما يكون الشرط أعلاه `True` (أي أن الحرف هو حرف متحرك)، يتم تنفيذ أمر `continue`.
    - `continue` تخبر الحلقة: "**توقف عن تنفيذ أي شيء آخر في هذه الدورة، واذهب مباشرة إلى بداية الحلقة لبدء الدورة التالية مع الحرف التالي**".
    - لهذا السبب، يتم تخطي السطر `al_jumla_al_jadida += harf` عندما يكون الحرف متحركاً.

5.  **`al_jumla_al_jadida += harf`**
    - هذا السطر هو اختصار لـ `al_jumla_al_jadida = al_jumla_al_jadida + harf`.
    - هذه العملية تسمى **"الدمج" (Concatenation)**. إنها تأخذ السلسلة الحالية وتضيف الحرف الجديد في نهايتها.
    - هذا السطر يتم الوصول إليه **فقط** إذا كان شرط الـ `if` خاطئاً (أي أن الحرف ليس متحركاً).

---

#### **✅ نقاط رئيسية ونصيحة للامتحان**

- **النقاط الأساسية التي يجب تذكرها:**

  - `continue` تتخطى **الدورة الحالية فقط** وتنتقل إلى التالية.
  - `break` تنهي **الحلقة بأكملها**.
  - `continue` مفيدة جداً لمهام **الفلترة** أو **تجاهل** بيانات معينة أثناء المرور على مجموعة.

- **نصيحة للامتحان:**
  - إذا طلب منك سؤال معالجة قائمة ولكن مع "تجاهل القيم السالبة" أو "تخطي الكلمات الفارغة"، فهذه إشارة واضحة إلى أن `continue` هي الأداة المناسبة. إنها تجعل الكود أنظف وأكثر وضوحاً من محاولة وضع كل المنطق داخل كتلة `if` واحدة كبيرة.

---

### **التمرين 9: لعبة تخمين الرقم (تمرين شامل)**

**الهدف:** دمج المتغيرات، الحلقات التكرارية (`while`)، الشروط (`if/elif/else`)، الإدخال/الإخراج، والتحكم في الحلقة (`break`) لبناء برنامج كامل.

**المطلوب:**
اكتب برنامجاً يقوم بالتالي:

1.  يختار البرنامج "رقماً سرياً" بين 1 و 10 (يمكنك وضعه مباشرة في الكود في البداية).
2.  يدخل البرنامج في حلقة تكرارية تطلب من المستخدم تخمين هذا الرقم.
3.  في كل مرة يخمن فيها المستخدم:
    - إذا كان تخمينه **أقل** من الرقم السري، يطبع البرنامج: "**أعلى!**"
    - إذا كان تخمينه **أكبر** من الرقم السري، يطبع البرنامج: "**أدنى!**"
    - إذا كان تخمينه **صحيحاً**، يطبع البرنامج رسالة تهنئة مثل "**أحسنت! لقد وجدت الرقم السري.**" ثم **يخرج من الحلقة** لإنهاء اللعبة.

خذ وقتك الآن لتجميع كل القطع التي تعلمناها معاً.

---

#### **الحل والشرح**

![alt text](image-9.png)

#### **شرح مفصّل**

1.  **`al_raqm_al_sirri = 7`**
    هنا ببساطة نحدد الرقم الذي يجب على اللاعب تخمينه.

2.  **`while True:`**

    - هذه طريقة شائعة جداً لإنشاء حلقة تريد أن تستمر حتى يحدث شيء معين (في حالتنا، تخمين الرقم الصحيح).
    - `True` هي قيمة منطقية (Boolean) تعني "صحيح". لذا، `while True` تعني حرفياً "طالما أن 'صحيح' هو 'صحيح'"، وهذا سيستمر إلى الأبد ما لم نوقفه يدوياً.
    - نحن نعتمد على أمر `break` داخل الحلقة للخروج منها في اللحظة المناسبة. هذا يجعل منطق البرنامج نظيفاً جداً.

3.  **`takhmeen = int(input(...))`**
    داخل الحلقة، نطلب من المستخدم تخمينه في كل دورة ونحوله إلى رقم صحيح للمقارنة.

4.  **سلسلة `if/elif/else`**

    - هذا هو "عقل" اللعبة. نحن نستخدم الشروط لمقارنة تخمين اللاعب بالرقم السري.
    - **`if takhmeen < al_raqm_al_sirri:`** : الشرط الأول يتحقق مما إذا كان الرقم منخفضاً جداً.
    - **`elif takhmeen > al_raqm_al_sirri:`** : إذا لم يكن الشرط الأول صحيحاً، نتحقق مما إذا كان الرقم عالياً جداً.
    - **`else:`** : هذه هي الحالة الذهبية. إذا لم يكن التخمين أقل من الرقم السري، ولم يكن أكبر منه، فمن المنطقي أنه **يساويه**. هنا نضع كود الفوز.

5.  **`break`**
    كما تعلمنا، `break` تكسر الحلقة فوراً. بمجرد أن يخمن اللاعب الرقم الصحيح، تتم طباعة رسالة التهنئة، ثم يتم تنفيذ `break`، فتتوقف حلقة `while True` وينتهي البرنامج.
